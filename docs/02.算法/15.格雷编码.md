---
title: 格雷编码
date: 2022-02-18 18:29:38
permalink: /pages/54e5cc/
categories:
  - 算法
tags:
  - 格雷码
---

## 描述

[89. 格雷编码](https://leetcode-cn.com/problems/gray-code/)

n 位格雷码序列 是一个由 2n 个整数组成的序列，其中：
每个整数都在范围 [0, 2n - 1] 内（含 0 和 2n - 1）
第一个整数是 0
一个整数在序列中出现 不超过一次
每对 相邻 整数的二进制表示 恰好一位不同 ，且
第一个 和 最后一个 整数的二进制表示 恰好一位不同
给你一个整数 n ，返回任一有效的 n 位格雷码序列 。

 

示例 1：

```
输入：n = 2
输出：[0,1,3,2]
解释：
[0,1,3,2] 的二进制表示是 [00,01,11,10] 。

- 00 和 01 有一位不同
- 01 和 11 有一位不同
- 11 和 10 有一位不同
- 10 和 00 有一位不同
  [0,2,3,1] 也是一个有效的格雷码序列，其二进制表示是 [00,10,11,01] 。
- 00 和 10 有一位不同
- 10 和 11 有一位不同
- 11 和 01 有一位不同
- 01 和 00 有一位不同
```


示例 2：

```
输入：n = 1
输出：[0,1]
```




提示：

- 1 <= n <= 16

## 解法

### 对称生成

```
n = 1  [0, 1]
n = 2  [00，01，11，10]
n = 3  [000, 001, 011, 010, 110, 111, 101, 100]
....
```

- 格雷码只有 [0, 1] 两个元素。且格雷码每增加1，包含的数字即翻倍。
- n 位格雷码前半部分是 n-1 位格雷码前面补 0 。

```
n = 2  [ 00， 01， 11， 10]
n = 3  [000, 001, 011, 010] # 前四个数
```

- n 位格雷码后半部分是 n-1 位格雷码前面补 0 ，并对数组逆序。

```
n = 2  [ 00,  01,  11,  10] 
补   1 [100, 101, 111, 110] 
逆  序 [110, 111, 101, 100] （后四个数）
```

最终代码为：

```python
class Solution:
    def grayCode(self, n: int) -> [int]:
        dp = ['0', '1']
        for i in range(2, n + 1):
            head = [f'0{x}' for x in dp]
            tail = [f'1{x}' for x in dp]
            tail.reverse()
            dp = head + tail
        return [int(x, 2) for x in dp]
```

### 二进制生成

从对称生成中可知，任意 n 位格雷杩，其前一半均为 n-1 位格雷码的全部。这时我们将格雷码编号：

```json
[000, 001, 011, 010, 110, 111, 101, 100 ...]
  0,   1,   2,   3 ,   4,   5,  6,   7,  ...
```

- 这里的0 ~ 7... 转换为二进制后我们成为二进制码，比如我们要求解5对应的格雷码，这里5对应的二进制码就是0101（5的二进制）

- 二进制码对应的每一位就是小b，，格雷码每一位是g，这里讲解过程中在前面补0方便理解，这里的\/就是异或的运算

  ```json
  0   0   1   0   1
  0   b3  b2  b1  b0
    \/  \/  \/  \/ 
    g3  g2  g1  g0
     0   1   1   1
  ```

- 所以我们由5（0101）推出对应的格雷码为0111

- 这里解释一下

  ```
  (i >> 1) ^ i
  ```

  ，i>>1其实将i每一位向后移动一位，这时和i取异或，相当于和自己的后一位取余

  ```json
  b3 b2  b1  b0  (i)
  0  b3  b2  b1  (i >> 1)
  g3 g2  g1  g0  (结果) 
  ```

最终代码为：

```python
class Solution:
    def grayCode(self, n: int) -> [int]:
        length = pow(2, n)
        res = [0] * length
        for i in range(1, length):
            res[i] = (i >> 1) ^ i
        return res
```

两种解法的复杂度均为：

- 时间复杂度：  $O(2^n)$
- 空间复杂度： $O(1)$
