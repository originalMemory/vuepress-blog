---
title: 三数之和
date: 2021-11-30 13:19:43
permalink: /pages/df8e3f/
categories:
  - 算法
tags:
  - 中等
  - 数组
---
## 描述

[15. 三数之和](https://leetcode-cn.com/problems/3sum/)

给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

示例 1：

```
输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
```

示例 2：

```
输入：nums = []
输出：[]
```

示例 3：

```
输入：nums = [0]
输出：[]
```


提示：

- 0 <= nums.length <= 3000

- -105 <= nums[i] <= 105

## 解法

核心思路是使用双指针。

先对列表进行一次排序，从低到高，然后遍历列表取返回值中最小数 a。则 b,c 必然在 $[a,n]$ 的区间里，且满足如下条件：

-  $a+b+c>0$ 时， $c-1$ 
-  $a+b+c<0$ 时， $b-1$ 
-  $a+b+c==0$ 时，即为答案。

再跳过相同值，由此可得算法：

```python
class Solution:
    def threeSum(self, nums: [int]) -> [[int]]:
        res = []
        # 先排序，便于遍历计算从小到大的 [first, second, third]
        nums.sort()
        n = len(nums)
        for first in range(n):
            # 跳过重复值
            if first > 0 and nums[first] == nums[first - 1]:
                continue
            third = n - 1
            for second in range(first + 1, n):
                # 跳过重复值
                if second > first + 1 and nums[second] == nums[second - 1]:
                    continue
                # 在保证大小顺序的前提下缩减 third
                while second < third and nums[first] + nums[second] + nums[third] > 0:
                    third -= 1
                # 相等时不需要再遍历，因为 second 再增加也不会有满足条件的值了
                if second == third:
                    break
                if nums[first] + nums[second] + nums[third] == 0:
                    res.append([nums[first], nums[second], nums[third]])
        return res
```

需要注意的是 `first` 和 `second` 需要跳过重复值，否则很容易出现重复答案。缩减 `third` 时也需要注意不能小于 `second` 。